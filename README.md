# Vault Engine SDK Documentation

By integrating with Vault Engine, developers can effectively introduce a plug and play backend to your application, largely side stepping responsibility of developing, managing, and maintaining many of the essential backend features critical to blockchain DAPP development. A more precise overview of features is available and why you should consider Vault Engine for you DAPP checkout vaultwallet.io/VaultEngineSDK

## Getting Started
These instructions will get you give you the resources needed to integrate Vault Engine into your product design roadmap, as well as begin development. The below SDK documentation is to be taken as a guide to developing your application with the Vault Engine SDK. Because the SDK is compiles natively to your target platform, the specific language you are using may present some differences in coding structure (callbacks etc). In the future we will provide a way to test this directly on the website. To simplify and ease the learning curve, the below documentation is written to be readable and functional, not exact code snippets. 

### Vault Engine Primitive Concepts
#### User Accounts 
A user account is created using a unique identifier generated by some kind of authentication mechanism, here oAUTH. You can think of a user account as the parent to all other data. On the Vault Engine Server a user account is used to associate public keys with human readable names, allowing seamless crypto user experiences. Additionally it is recommended that a recover nemonic is generated to be associated with the user account. By doing this future private key pairs (Key Accounts) will be recoverable easily by the end user. When a user account is deleted from a device, the SDKs deletes all local information associated with that user account, such as private/public keys, cached transaction information, etc. 

#### Key Accounts 
Within the Vault Engine SDK key accounts are the name for a public + private key pair and the associated metadata included along with them. Conceptually, you can think of this as a child object of a User Account, because each key account is associated with a User. 
> * alletAccount` is an object representing the `publicAddress`, `type` and `nickname`**

#### Shared Accounts
A shared account is type of key account in which the public key is publicly available to other app users via a 'connection'. Unlike a default key account, this type of account, and its associated stored coins, will be both visible to your connections; as well as the endpoint which others will transact too. For example if two users were to wish to transact using Shared Accounts, each person would see and transact to each other persons shared account (think abstracted public key). 
> * haredAccount` is an object representing the `public address`, `type`, `isMyAccount`, `nickname`and `userId`** -- All the accounts you share to others and the accounts shared to you
#### Connections
Connections can be thought of as 'friends'. Using this feature of the SDK allows abstraction of public keys and surfacing of simple human readable account names associated definitively with users. Akin to social features, connections can be sent, received, accepted, and denied. A master list of all connection names (users) is stored in the Vault Engine cloud backend so each instance can query a live list.  

### User Accounts and Authentication
#### Add/Update Account
Create a user account to manage authentication of users and user metadata locally. 
```
val userAccount = vault.addUserAccount(jwt, userId, name, email)
```
> * jwt - 
> * userId - 
> * name - 
> * email - 
#### Remove Account
Delete a user account an all associated data from the local device. This includes private keys.
```
userAccount.removeAccount()
```
#### Check Account Exists
Check if an account exists on the local device.
```
val isConnected: Boolean = userAccount.isConnected()
```
### Key Account and Key Account Management
#### Get all Key Accounts
Retrieve a list of wallet key accounts associated with the current user account.
```
VaultWallet.getWalletAccounts((walletAccounts) => {
  console.log(walletAccounts)
})
```
> * walletAccounts -
### Get Key Account for KeyAlias
Key accounts have an associated alias locally. You can pull for these key alias 
```
val walletAccount = vault.getWalletAccount(keyAlias)
```
> * keyAlias - 
#### Observing **my** Wallet Key Accounts
To setup a listener for one of your wallets, so that you can receive notifications of changes in wallet activity, use the following call. 
```
DeviceEventEmitter.addListener(walletAccounts)
```
> * walletAccounts - 
#### Delete/Stop tracking the account
Delete a key account from the current user. This deletes the private key locally as well as all meta data associated with this key account. 
```
vault.deleteAccount(walletAccount)
```
> * walletAccount -
### Shared Accounts
#### Share a key account with user
Expose a current account as a shared account to a specified user on the service. 
```
vault.shareAccount(userId, walletAccount)
```
> * userId - 
> * walletAccount - 
#### Unshare an key account with user
Remove visibility of a shared account from a specified user on the service. 
```
vault.unshareAccount(userId, walletAccount)
````
> * userId - 
> * walletAccount - 
#### Get all shared key accounts relationships
Retrieve a list of all of the currently shared key accounts associated with the current user?
```
var sharedAccounts = UserAccount.getAllConnections();
```
#### Observing shared accounts
Place a listener on a shared account such that you will be notified when there is activity changes in that account. 
```
vault.startObservingSharedAccounts(callback)
...
vault.stopObservingSharedAccounts(callback)
```
### Connections and Connection Management
#### Get all connections
Retrieve a list of the current (accepted) connections associated with the current user. 
```
var connections = vault.getConnections()
```
### Start/Stop Observing connections changes
Place a listener on connections. For example, I wish to know when another user x has accepted my connection request. 
```
vault.startObservingConnections(walletAccounts, callback)
...
vault.stopObservingConnections(callback)
```
> * walletAccount - 
#### Find a connection
Query the vault wallet server for a particular user based on the searchQuery string. 
```
vault.findConnection(searchQuery, callbackWithIds)
```
> * searchQuery - String containing search query ex. John Smith
#### Add a connection
Add a connection to your local connection list and send a connection request to the corresponding user (think friend request). 
```
vault.addConnection(userId)
```
> * userId - user ID received from the findConnection(...) call 
#### Accept a connection request
Accept a currently pending connection request
```
vault.acceptConnectionRequest(userIdOrSearchResultId)
```
> * userIdOrSearchResultID - user ID received from the findConnection(...) call SAME THING?????
#### Decline a connection request
Decline a currently pending connection request
```
vault.declineConnectionRequest(userIdOrSearchResultId)
```
#### Get a pending connection request
Get a list of all currently pending connection requests
```
var pendingRequests = vault.getPendingRequests()
```
#### Start/Stop Observing Pending Connection Requests
Listen for state changes on currently pending connection requests. 
```
vault.startObservingConnectionsRequests(callback)
...
vault.stopObservingConnectionRequests(callback)
```
### Mnemonic
Mnemonic's allow users to recover their private keys with a backup seed they have saved. Each user account should have a mnemonic associated with it so that wallets can be generated with them. It is considered best practice to do this at the UX level fairly soon after user account creation. 
#### Generate a Mnemonic seed
```
var generatedMnemonicSeed = vault.generateSeed(wordSize)
```
> * wordSize - Word Size can be 16, 20, 24, 28 or 32, larger is more secure.
#### Import from seed (or generate). 
*This will register the `WalletAccount` automatically with the backend. The key alias can be public -- no need to treat it like a password.*
```
var keyAlias = vault.importMnemonic(menmonicString, addressIndex = 0)
```
> * mnemonicString -
> * addressIndex- 
#### Get Public Address of a Mnemonic
*CryptoObject is used in conjunction with the SE/TEE to validate user biometric authentication ~(optional)~.*
*We are decomposing the key alias which has the public address of address 0 of the mnemonic*
```
val publicAddress = vault.getPublicAddress(mnemonicString, addressIndex = 0)
// OR
val publicAddress = vault.getPublicAddress(keyAlias, addressIndex = 0, cryptoObject?)
```
> * mnemonicString -
> * value addressIndex- 
> * cryptoObject? - 
#### Show Mnemonic
```
vault.showMnemonic(keyAlias, cryptoObject?, callback)
```
> * keyAlias - 
> * cryptoObject? -

#### Cloud backup - Keep or leave? 
```
vault.cloudBackup(keyAlias, cryptoObject?, callback)
```
> * keyAlias - 
> * cryptoObject? -
#### Import cloud backup - Keep or leave? 
```
vault.importCloud()
```
#### Generate Another wallet from a mnemonic
Generate a key account which is recoverable with the user accounts stored mnemonic
```
var publicAddress = vault.createWallet(keyAlias, nameOfWallet, addressIndex = 0, cryptoObject?)
// OR
var publicAddress = vault.createWallet(mnemonicString, nameOfWallet, addressIndex = 0, cryptoObject?)
```
> * mnemonicString - 
> * nameOfWallet - 
> * value addressIndex- 
> * cryptoObject? - 

### Get Transactions for Specific Key Accounts
```
var transactions = vault.getTransactions(walletAccounts)
```
### Observing Transactions on Specific Key Accounts
```
vault.startObservingTransactions(walletAccounts, callback)
...
vault.stopObservingTransactions(callback)
```
### Send Transaction
Sign and send a transaction to the blockchain
```
vault.postTransaction(accountFromkeyAlias, toAddress, value, cyrptoObject?, callback)
```
> * accountFromKeyAlias - 
> * toAddress - 
> * value - 
> * cryptoObject? - 

### Realtime Connectivity Status
#### Get current connected state
If you need to check if the wallet is currently connected to the blockchain through Vault Wallets backend servers use the following call. 

```
VaultWallet.isConnected(
  (connected) => {
    console.log("Connected: " + connected)
  }
);
```
#### Observing connected state
Listener will notify if the Wallet is connected or disconnected to the internet. 
```
DeviceEventEmitter.addListener('connectionChange', function(e: Event) {
    console.log("Connected: " + e.connected)
})
```

## Authors

* **Rahul Behera** - *Initial work* - [Vault Wallet](https://github.com/thebehera)
* **Josh Kruger** - *Version_2* - [Vault Wallet](https://github.com/gondee)

## License

To procure a license to use the Vault Engine SDK, please visit VaultWallet.io and drop us a line. 
